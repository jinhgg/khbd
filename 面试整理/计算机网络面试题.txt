1.TCP为什么需要3次握手
“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”
一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

2.TCP和UDP有什么区别？
- TCP（Transmission Control Protocol）：传输控制协议，客户端和服务器传输数据前要建立连接，此连接需要经过三次对话建立，由于建立了连接，提供数据超时重发，丢弃重复数据等数据，因此适合传输大量数据，但传输速度比较慢。

- UDP（User Datagram Protocol）：用户数据协议，不必建立连接，客户端和服务器之间直接将IP层的数据包发送出去，不能保证数据是否成功到达目的地，也没有超时重发等机制，但传输速度很快，适合小数据，可靠要求不高的数据传输。

3.TCP/IP的流量控制？
利用滑动窗口实现流量控制
https://www.zhihu.com/question/48454744/answer/110946313

4.HTTP的长连接和短连接?

在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。使用长连接的HTTP协议，会在响应头加入这行代码：
Connection:keep-alive

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。如果不是用长连接
Connection:close


在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

5.IO中同步与异步，阻塞与非阻塞区别

同步和异步关注的是消息通信机制
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。
而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

同/异步是指消息通信机制：返回结果(消息)以什么样的方式返回给你
1有就给你，没有就等到有再给你
2有没有都给你一个回复让你不必等，有了再给你
阻塞/非阻塞是程序在等待调用结果时的状态：在等待返回结果(消息)的时候你在干什么
1我等他返回给我我再做别的事
2我不会因为等待返回而耽误别的事

6.Cookies 和 Session的区别
cookie
cookie 是 http 协议的一部分，它的处理分为如下几步：
服务器向客户端发送 cookie。
	通常使用 HTTP 协议规定的 set-cookie 头操作。
	规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。
浏览器将 cookie 保存。
每次请求浏览器都会将 cookie 发向服务器

session
cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。
session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。

cookie存在客户端。session存在服务器
session可以存在服务器的内存，数据库，文件
session也可以不存在服务器中，直接以键值对然后对称加密完全交给cookie存在客户端，解密方法只有服务器知道
session是在cookies基础上实现的

7.什么是TCP粘包、TCP粘包发生了怎么处理？

基于TCP的socket编程，
1.发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包发送(把发送端的缓冲区填满一次性发送)。
2接收端底层会把tcp段整理排序交给缓冲区，这样接收端应用程序从缓冲区取数据就只能得到整体数据而不知道怎么拆分 
这两个原因是tcp是面向流的协议

比如发送端发送了一个由2个100字节组成的200字节的数据包到接受端的缓冲区，接受端从缓冲去一次取80字节的数据，那么第一次取的就是一个不完整的数据包，第二次取就会带上第一个数据包的尾部和下一个数据包的头

注：一次取多少数据通过socket.recv(80)定义



为什么udp不会粘包
1.TCP协议是面向流的协议，UDP是面向消息的协议
UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据

2.UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。接收端一次只能接收发送端发出的一个数据包,如果一次接受数据的大小小于发送端一次发送的数据大小，就会丢失一部分数据，即使丢失，接受端也不会分两次去接收



举例：

用socket写一个客户端和服务器，客户端发送命令让服务器执行并返回执行结果，如ls 然后返回结果有很多行，由于客户端一次只接受一点数据，只显示一部分文件，下一次执行pwd命令，返回会带有上次没显示完的文件名

TCP粘包发生了怎么处理？
（1）发送方 
对于发送方造成的粘包现象，我们可以通过关闭Nagle算法来解决，使用TCP _NODELAY选项来关闭Nagle算法。 
（2）接收方 
遗憾的额是TCP并没有处理粘包现象的机制，我们只能在应用层处理。 
（3）应用层处理 
　1）格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符；

　2）发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。


什么时候要处理粘包现象
（1）如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；

（2）但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。比如，我当时要接收的每个分组都是一个有固定格式的商品信息，如果不处理粘包问题，每个读进来的分组我只会处理最前边的那个商品，后边的就会被丢弃。这显然不是我要的结果。

8.TCP中的time_wait是什么情况？出现过多的close_wait可能是什么原因？
参考图片和文章：
http://baijiahao.baidu.com/s?id=1583638260236071388&wfr=spider&for=pc

对Client而言：
TCP 的Client发出FIN结束报文以后，client 进入FIN_WAIT_1状态，从而等待server的ACK , 收到ACK以后表明从client到server的连接断开了，此时client进入FIN_WAIT_2状态。
如果client收server传来的FIN以后，client 会发送一个ACK，然后进入TIME_WAIT状态。client需要在TIME_WAIT保持2MSL的时间才会进入CLOSED状态。
注：MSL即 Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间

对Server 而言
当server 收到client发过来的断开连接的FIN包以后，会进入CLOSE_WAIT状态，并向上层应用通告这个消息，同时返回ACK ，至此client到server的连接断开了。
上层应用处理完相关的信息以后会向client发送FIN， 进入LAST_ACK状态，等待client返回ACK ,如果收到ACK，至此server到client的连接断开，server进入CLOSED状态。

注意：出现过多的close_wait的原因就是在这里，上层处理信息出现了问题，未能关闭socket，所以就没有发出FIN，导致服务器一直停在CLOSE_WAIT状态，解决方法就是通过Socket.setSoTimeout()设置socket超时时间
所以TIME_WAIT 表示主动关闭，是主动关闭连接时形成的，CLOSE_WAIT 表示被动关闭 ，是被动关闭连接是形成的。

9.epoll,select的区别？边缘触发，水平触发区别？

我们先来看一下socket简单的通信
服务器：

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);   
    sock.bind(('localhost', 8001));       
    sock.listen(5);

    while True:
        conn, addr = sock.accept();
        szBuf = conn.recv(1024);
        conn.send('welcome client!');
        conn.close();
客户端：
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
    sock.connect(('localhost', 8001));
    sock.send('0');
    szBuf = sock.recv(1024);
    sock.close();
    print("end of connect");

这样的简单模型服务器只能与一个客户端连接：
服务器conn, addr = sock.accept();对应客户端sock.connect(('localhost', 8001));
想要实现并发送，可以开多进程也可以通过io多路复用，这里谈后者，通过select实现服务器同时与多个客户端建立连接，并监听
服务器改写为：

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);   
        sock.bind(('localhost', 8001));       
        sock.listen(5);
	inp=[soket,]

    while True:
	
        r,w,e=select.select(inp,[],[])
	for i in r:
	#如果有新的客户端进来连接服务器socket，服务器socket在内核空间就有变化，r被赋值服务器socket
 	    if i==socket:
		conn, addr = i.accept();#拿到客户端的socket，这时r就归零
		szBuf = conn.recv(1024);#数据从内核拷贝到用户空间
		conn.send('welcome client!');
                inp.append(conn)#将客户端socket加入监听
	#如果监听的客户端soket中有一个发了数据，该客户端socket在内核空间有变化，r就代表那个客户端socket
	    else:
		data=i.recv(1024)#数据从内核拷贝到用户空间，这时r就归零


select.select(inp,[],[])监听服务器和若干客户端的socket，一旦某个描述符(socket)就绪（一般是读就绪或者写就绪）即该描述符号在内核空间有变化，就会被赋值给r(直到执行accept())，然后会执行r.accept()，把数据从内核拷贝到用户空间,之后该socket就不在r中

通过select.select(inp,[],[])来监听自己的socket有没有被的客户端连，如果有客户端连，就通过下面的循环把客户端的socket拿到加入到inp里面让seclet监听，这样select就监听了自己和另一个客户的的socket
如果再来一个连接依然会被加入监听，这样就实现了监听多个客户端

以上就是select的用途

select,poll和epoll之间的区别：
select只能监听1024个socket，当有描述符就绪后，需要遍历所有监听事件
poll在监听的描述符数量上没有限制
epoll通过红黑树，不需要遍历
三者的具体实现：https://www.jianshu.com/p/abfb47d36fba


简述I/O多路复用
I/O多路复用实际上就是在单个线程上，用select, poll, epoll监听多个io对象(socket)，当socket有变化的时候就通知用户进程，完成后序操作

边缘触发，水平触发区别？

水平触发(又叫条件触发):就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知
边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知

上面的select是水平触发，因为只要内存里有数据读就绪，就触发，如果通过i.accept()将数据取出就不在触发，如果if i==socket:
里面没有i.accept()，他就会不断在里面无限循环

10. tcp三次握手， 四次挥手

三次握手：
第1步 ：客户端向服务器发送一个同步数据包请求建立连接，该数据包中，初始序列号ISN(Initial Sequence Number)是客户端随机产生的一个值，确认号是0；
发送端  SYN=1，(序列号)Seq=ISN(c),确认号(acknumber)=0  接收端

第2步 ：服务器收到这个同步请求数据包后，会对客户端进行一个同步确认。这个数据包中，序列号（ISN）是服务器随机产生的一个值，确认号是客户端的初始序列号+1；
发送端  SYN=1,ACK=1，(序列号)Seq=ISN(s),确认号(acknumber)=ISN(c)+1  接收端

第3步 ：客户端收到这个同步确认数据包后，再对服务器进行一个确认。该数据包中，序列号是上一个同步请求数据包中的确认号值，确认号是服务器的初始序列号+1。
发送端  ACK=1，(序列号)Seq=ISN(c)+1,确认号(acknumber)=ISN(s)+1  接收端

tcp数据传输：
关键要搞清seq和ack的值
如果知道上面：
seq=上一个ack
ack =上一个seq+上个数据大小


seq  ack  大小  方向
811  0    1      >
818  812  1      <
812  819  0      >
812  819  517    >
819  329  0      <
819  329  1440   <
329  259  0      >
259  329  1369   <
329  628  0      >

四次挥手：
TCP连接是数据在两个方向上能同时传递,因此每个方向必须单独地进行关闭

第一次挥手：客户端先发送FIN报文，用来关闭主动方到被动关闭方的数据传送，也就是客户端告诉服务器：我已经不会再给你发数据了，但此时客户端还可以接受数据。
第二次挥手：Server端接到FIN报文后，服务器端先发送ACK，告诉Client端：请求已经收到了，但是我的数据可能还没有发完，接下来我可能还会发数据，请等待我含有FIN标识的消息。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文
第三次挥手：当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端：服务器这边数据发完了，准备好关闭连接了。
第四次挥手：Client端收到FIN报文后，发送ACK表示收到，知道可以关闭连接了，但是他还是不相信网络，所以后进入TIME_WAIT状态，Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，最后，Client端也可以关闭连接了至此，TCP连接就已经完全关闭了
#MSL(Maximum Segment Lifetime)报文最大生存时间
#客户端发送最后一个针对服务器的FIN的ack之后，担心ack丢包，如果丢包服务器就会重发FIN，从丢包到重发不会超过2MSL，所以客户端要等待这么一段时间

#SYN和FIN都占一个字节



		
        









