1.数据库事务的四个特性及含义

数据库事务的4个特性：原子性、持久性、一致性、隔离性
原子性：事务是最小业务单元，不可再分
一致性：事务保证所有sql语句全部成功或者全部失败
隔离性：处理独立的业务，彼此之间不影响
持久性：在事务完成后，该事务所有的操作都将持久化在数据库中，一旦提交不会被回滚

2.数据库索引使用了什么数据结构？
mysql使用 B树


4.MySQL中myisam与innodb的区别 (show engines \G)

innodb支持事物， myisam不支持事物
innodb支持行级锁， myisam支持表级锁
innodb支持外键， myisam不支持
innodb不支持全文索引，myisam支持

myisam与innodb的使用场景？
1、MyIASM管理非事务表,提供高速存储和检索以及全文搜索能力,如果再应用中执行大量select操作,应该选择MyIASM 
2、InnoDB用于事务处理,具有ACID事务支持等特性,如果在应用中执行大量insert和update操作,应该选择InnoDB

还有memory 它将数据存在内存中，用于存储临时数据，速度非常快


什么是外键？
a表的属性1是b表的主键.属性1是a表的外键，b是a的父表


9.mysql字符集和排序规则？
字符集最常用的包括：
utf8,gbk,
排序规则:
字符集名字_语言_后缀， 如：utf8_general_ci
1. _ci：不区分大小写的排序方式
2. _cs：区分大小写的排序方式
3. _bin：二进制排序方式

10.varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符？
一个是固定长度,一个是可变长度
大小限制:
char(M1) varchar(M2) M指字符数
M1=0-255字符  M2=0～21845/32766字符     注释:21485=65535/3 32766=65535/2
如果采用utf8，1字符等于3字节，如果采用gbk，1字符等于2字节


11.primary key和unique的区别？
一个表只能有一个primary key， 一个表可以有多个unique key。
unique key约束只针对非主键列， 可以为空值， primary key约束针对主键列， 不允许有空值


12.外键有什么用，是否该用外键？外键一定需要索引吗？
外键是为了一张表记录的数据不会太过冗余，也是为了数据的一致性和完整性。

如果业务逻辑相当的复杂那么建议使用外键来保证数据的一致性和完整性， 如果业务逻辑不复杂则可以不使用外键， 仅靠程序中来保证数据的一致性和完整性， 或者业务对数据的一致性完整性要求相当的高， 那么一定要用外键。同时如果为了不让mysql在性能有任何的形象应该避免使用外键。 所有应该视当前业务，数据等情况决定是否使用外键

是的，mysql会自动为外键创建索引


13.索引有什么用？
对字段进行排序，帮助快速查找
执行select语句时候的条件如果是加了索引的，就不需要对数据表做全表扫描，使用类似二分查找
例如主键(id primary key unique 是唯一性索引)用它的值作为查找的条件会很快

为什么索引不是越多越好？
1).索引需要占物理空间,除了数据表占数据空间之外,每一个索引还要占一定的物理空间
2).当对表中的数据进行增加、删除和修改的时候,索引也会更新,索引越多,所花的时间越长

怎么设计索引？
1).作为查询经常出现在 where 条件中或经常需要搜索的列上,可以加快查询的速度
2).尽量能使用唯一索引，例如手机号，出生日期，不要是性别之类的
3).如果是长字符串，最好指定索引长度,这样查询快
4).在经常用在连接的列上,这些列主要是一些外键,可以加快连接的速度
5).在经常需要根据范围进行搜索的列和需要排序的列上创建索引,因为索引已经排序,其指定的范围是连续的，这样查询可以利用索引的排序,加快排序



==================================================================================================================
事务四大特性（ACID）
(1) 原子性(Atomicity)
事务包含一项业务的所有操作，不可再分
(2) 一致性(Consistency)
事务包含的所有操作要么全部成功,要么全部失败回滚的一致性。
(3) 隔离性(Isolation)
隔离性是当多个用户并发访问数据库时,比如操作同一张表时,数据库为每一个用户开启的事务,不能被其他事务的操作所干扰,多个并发事务之间要相互隔离。
(4) 持久性(Durability)
持久性是指一个事务一旦被提交了,那么对数据库中的数据的改变就是永久性的,即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。


数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别？
1.Read Uncommitted(读取未提交内容) => 脏读
所有事务都可以看到其他未提交事务的执行结果
2.Read Committed(读取提交内容) => 不可重读
一个事务只能看见已经提交事务所做的改变，同一事务的其他实例在该实例处理其间可能会有新的commit,所以同一select可能返回不同结果
3.Repeatable Read(可重读) 默认 => 幻读
同一事务的多个实例在并发读取数据时,会看到同样的数据行，幻读 当用户读取某一范围的数据行时,另一个事务又在该范围内插入了新行,当用户再读取该范围的数据行时,会发现有新的行
幻读和不可重复，都是两次查询结果不一样，但幻读会读到其他事务的插入(insert)的数据，不可重复读是独到数据的修改(update delete)导致前后读取不一致
4.Serializable(可串行化)
最高的事务隔离级别,同时代价也花费最高,性能很低,一般很少使用,在该级别下,事务顺序执行,不仅可以避免脏读、不可重复读,还避免了幻读


数据库的优化？

1.explain的使用及各字段分析
值得注意的字段:
1).type: (尽量达到eq_ref>ref>range)
system>const>eq_ref>ref>range>index>all 性能排行
system只有一条数据的系统表
const使用了主键或者唯一索引查询，结果只有一条
eq_ref和const一样，在连表查询中出现，连表条件是唯一索引
ref使用非唯一索引，结果可以有多条
range使用索引，查询了一个范围
index虽然有索引，但扫描了全部索引表
all索引失效

2).key
查看使用了那些索引

3).Extra
using filesort:性能消耗大；需要“额外”的一次排序（查询）  。常见于 order by 语句中
using temporary:性能损耗大 ，用到了临时表。一般出现在group by 语句中
using where:需要回表查询
using index :性能提升; 索引覆盖,不需回表查询读，只从索引文件中获取数据，只要使用到的列 全部都在索引中就是using index

sql优化:
一、导致索引失效的情况
1).避免在 where 子句中使用!=,<>,is null,is not null
2).避免在 where 子句中使用 or 来连接条件,使用union来连接两个查询
3).like查询以“常量”开头，不要以'%'开头
4).范围查询使用between代替in
5).不要在索引上操作如:计算、函数、类型转换
6).不要使用类型转换 如果name是varchar类型就不要where name=123

二、避免出现using filesort，using temporary
using filesort:查那些字段，就用这些字段排序order by
using temporary:查那些字段,就用这些字段分组group by

三、其他情况
有子查询的时候，尽量用exists替换in
放弃使用select *， 需要什么数据就取出什么数据


索引有B+索引和hash索引，各自的区别？
BTREE索引: btree的每个节点存储索引值和该记录的地址，查找的时候类似于二分查找
hash索引: 把索引值通过哈希函数返回一个地址，把该记录存储在此地址中，查找的时候根据索引计算的出的地址精确查找

区别:
1).如果是等值查询,那么哈希索引明显有绝对优势,一次算法即可找到相应的值
2).哈希索引无法优化范围查询和排序和like ‘xxx%‘模糊查找
3).在有大量重复键值情况下,哈希索引的效率也是极低的,因为存在所谓的地质冲突问题

memory存储引擎使用hash索引


索引的分类，最左前缀原则？
普通索引:最基本的索引,没有任何限制
唯一索引:与"普通索引"类似,不同的就是:索引列的值必须唯一,但允许有空值。
主键索引:它 是一种特殊的唯一索引,不允许有空值。
全文索引:仅可用于 MyISAM 表,针对较大的数据,生成全文索引很耗时好空间。
组合索引:为了更多的提高mysql效率可建立组合索引,遵循”最左前缀“原则

最左前缀原则:
出现在多列索引的使用上
在使用多列索引时从最左边的索引开始，依次使用，不要跨列
如：多列索引(name,age,address)
where name=xxx type:ref 索引发挥作用
where age=xxx  type:index 虽然用到索引但检索了整个age表，效率低
where address=xxx type:index 同上
where name=xxx and age=xxx and address=xxx type:ref 按顺序使用索引发挥作用
where age=xxx and address=xxx type:index 跨列使用索引效率低
where age=xxx and name=xxx and address=xxx type:ref 虽然没有按照索引顺序，由于底层sql优化器的存在，仍然按索引使用顺序


聚集索引和非聚集索引区别？
聚集索引: 表中存储的数据按照索引的顺序存储
非聚集索引: 数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置

主键就是聚集索引，数据的排序是根据主键来的，在别的字段上建一个索引，不会改变数据排列顺序，所以建的是非聚集索引，一个表只能有一个聚集索引，但一个聚集索引可以有多列


有哪些锁（乐观锁悲观锁），select时怎么加排它锁

共享锁(读锁):读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改
排他锁(写锁):写锁是排他的，写锁会阻塞其他的写锁和读锁
读读不阻塞 读写阻塞 写写阻塞

悲观锁:
在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作

乐观锁:
操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现)

定心丸：即使我们不会这些锁知识，我们的程序在一般情况下还是可以跑得好好的。因为这些锁数据库隐式帮我们加了对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预

表锁操作:
LOCAL TABLE 表名 READ/WRITE //添加读/写锁
UNLOCK TABLES  //释放锁

行锁操作:
在innodb引擎中，把自动提交关了，就是行锁set autocommit =0

参考:https://blog.csdn.net/sunhuaquan/article/details/6202635

select * from xxx for update  //select时加排它锁


https://v.youku.com/v_show/id_XNzI4Nzc3MjI0.html?spm=a2h0k.11417342.soresults.dtitle


关系型数据库和非关系型数据库区别？
后期再答


数据库三范式？
第一范式要求确保表中每列的原子性，也就是不可拆分
姓名  居住地
xxx   中国，江苏省，南京市
不符合第一范式，因为居住地可以拆分为国家，省，市

第二范式要求要有主键，要求其他字段都依赖于主键
学生id 姓名 班级 班主任
1      xxx  2    xxx
不符合第二范式，姓名依赖学生id(主键)，其余字段不依赖，应建学生表和班级表，用外键连接

第三范式就是要消除传递依赖，可以看做是“消除冗余”
学号 姓名 年龄 性别 所在院校 院校地址 院校电话
1    xxx  17   x    xxx      xxx      xxxxx
存在传递依赖 学号 <-- 所在院校 <-- (院校地址，院校电话)
也存在冗余
这样的表结构，应该建两表，如下。
学号 姓名 年龄 性别 院校id -- 院校id，院校地址，院校电话
参考https://www.jianshu.com/p/0355d9e5ba0e
https://www.cnblogs.com/knowledgesea/p/3667395.html
