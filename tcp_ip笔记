各个协议的依赖是怎样的，彼此怎么封装的

最小单位：bit/位/比特位
字节=byte  
1字节/byte=8位/bit
二进制一个数字代表一bit/位
比特流就是一串二进制信息


ARP属于哪一层?
由于IP协议使用了ARP协议，所以经常把ARP协议划归到网络层，但是ARP协议的用途是为了从网络层使用的IP地址解析出在数据链路层使用的硬件地址即MAC地址，所以有些地方也把ARP协议划归到数据链路层，但是一般情况下，我们还是把ARP和RARP协议划分到网络层

第一章


1.2分层

每一层负责不同的功能:
1) 链路层：包括操作系统中的设备驱动程序和计算机中的网卡，它们一起处理与电缆(或其他任何传输媒介)的物理接口细节。
2) 网络层：处理分组在网络中的活动,如分组的选路
3 ) 运输层：主要为两台主机上的应用程序提供端到端的通信
4 ) 应用层：负责处理应用程序细节

网络接口层和应用层的目的是很显然的 — 前者处理有关通信媒介的细节(以太网、令牌
环网等),而后者处理某个特定的用户应用程序( F T P、Te l n e t等)。但是,从表面上看,网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢?

应用层和运输层使用端到端协议。只有端系统需要这两层协议。但是,网络层提供的却是逐跳协议,两个端系统和每个中间系统(如路由器)都要使用它。

1.3 TCP/IP的分层

图1-4 展示了各层的协议以及他们之间的依赖
说明了各协议会在哪一章详细介绍

1.4 互联网的地址

ip地址的分类
A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 127.255.255.255）； 
B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； 
C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；
D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；
E类地址：以11110开头，第一个字节范围：240~255（240.0.0.0 - 255.255.255.255）；
# 子网掩码的作用：
# ip地址和子网掩码作与运算，得到的结果是ip地址的网络号
# a类ip的子网掩码是255.0.0.0(01111111.00000000.00000000.00000000)
# 所以a类网络号是除第一位0的后7位，主机号是剩下的24位
# b类网络号是除前两位10后的14位，主机号是剩下的16位，其他类以此类推
# 网络号代表所处的网络，主机号代表可以连接的主机数，可以看出a类可以连接的主机最多

1.5 域名系统

14章再详细谈

1.6 封装

数据经过每一层都会加上该层的头部信息，称之为封装
TCP传给IP的数据单元称作TCP报文段或简称为TCP段(TCP segment)。
UDP传给IP的数据单元称作TCP报文段或简称为UDP数据报。
IP传给网络接口层的数据单元为分组(packet)，分组可以是一个IP数据报(IP datagram)，也可以是IP数据报的一个片(fragment)。11.5节
通过以太网传输的比特流称作帧(Frame)

1.7 分用

当目的主机收到一个以太网数据帧时,数据就开始从协议栈中由底向上升,同时去掉各层协议加上的报文首部。
每层协议盒都要去检查报文首部中的协议标识,以确定接收数据的上层协议。这个过程称作分用

1.8 客户-服务器模型

服务器分为两种类型:重复型或并发型

1.9 端口号

TCP和UDP采用16bit的端口号来识别应用程序
服务器一般都是通过知名端口号来识别的 如http：80， ftp：21
客户端口号都是作临时端口号，只是在用户运行该客户程序时才存在

1.10 标准化过程  1.11 RFC  1.12 标准的简单服务 1.14 实现：tcp版本变迁  1.15 应用编程接口：socket和TLI
1.16 测试网络  1.17 小结
几个国际机构控制着TCP/IP协议族,定义新的标准以及其他类似的事情


第二章 链 路 层

2.1 引言

链路层主要目的:
(1)为IP模块发送和接收IP数据报;
(2)为ARP/RARP模块发送请求和接收ARP/RARP应答;

2.2 以太网和IEEE 802封装

这是链路层两种对数据的封装格式，现在以以太网为主

2.3 尾部封装

是另一种用于以太网的封装格式，已弃用

2.4 SLIP:串行线路IP 
 
是一种在串行线路上对 I P数据报进行封装的简单形式

2.5 压缩的SLIP  2.6 PPP:点对点协议

这里总结链路层提到的协议：
以太网，802.3，SLIP，PPP

2.7 环回接口

127.0.0.1  
一个传给环回接口的 I P数
据报不能在任何网络上出现，IP数据报离开网络层时把它返回给自己

2.8 最大传输单元MTU

每一个链路层的协议都有一个最大传输单元，如以太网最大为1500
ip数据报如果超过就要进行分片

2.9 路径MTU

两个计算机连接要通过多个网络，每个网络的链路层就可能有不同的MTU，如何确定MTU，以后再谈

2.10 串行线路吞吐量计算
不谈


第三章 IP:网际协议


3.1 引言

TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输
不可靠，丢弃数据报,然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供
无连接，每个数据报的处理是相互独立的，可能选择不同的路线，到达顺序可以不同

3.2 IP首部

一个ip数据报各字段：

版本 首部长度 服务类型 总长度
标识 标志 片偏移  (这一行在分片的时候11.5)
生存时间TTL 协议 首部检验和
源IP
目的IP
选项(如果有)
数据

作用：
生存时间TTL：字段设置了数据报可以经过的最多路由器数，经过一个路由器,它的值就减1，当该字段的值为0时,数据报就被丢弃,并发送ICMP报文通知源主机
协议：表示它的上层是tcp or udp or ...
首部检验和：生成ip数据报的时候基于ip首部信息产生，接受方检验，不通过就丢弃，等待再次发送

3.3 IP路由选择
路由表中包含目的ip地址和它的下一跳
1) 搜索路由表,寻找能与目的IP地址完全匹配的表目(网络号和主机号都要匹配)。如果找到,则把报文发送给该表目指定的下一站路由器或直接连接的网络接口
2) 搜索路由表,寻找能与目的网络号相匹配的表目。如果找到,则把报文发送给该表目指定的下一站路由器。目的网络上的所有主机都可以通过这个表目来处置。例如,一个以太网上的所有主机都是通过这种表目进行寻径的。
3) 搜索路由表,寻找标为“默认(default)”的表目。如果找到,则把报文发送给该表目指定的下一站路由器。
为一个网络指定一个路由器,而不必为每个主机指定一个路由器,这是 I P路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模

3.4 子网寻址

把主机号再分成一个子网号和一个主机号
A类和B类地址为主机号分配了太多的空间,事实上,在一个网络中人们并不安排这么多的主机
例如,这里有一个B类网络地址(140.252),在剩下的16bit中,8bit用于子网号,8bit用于主机号,这样就允许有254个子网,每个子网可以有254台主机
与30个C类地址相比,用一个包含30个子网的B类地址的好处是,它可以缩小Internet路由表的规模

3.5 子网掩码3.6 特殊情况的IP地址  3.7 一个子网的例子  3.8 ifconfig命令  3.9 netstat命令  3.10 IP的未来  3.11 小结
上面介绍过，不谈


第四章 ARP:地址解析协议


4.1 引言

ARP为IP地址到对应的硬件地址之间提供动态映射

4.2 一个例子

假设一个ftp/HTTP应用和一台主机(baidu.com)发起连接，经过以下步骤：

1)应用程序FTP/HTTP客户端调用DNS把主机名(baidu.com)转换成IP地址。
2)FTP/HTTP客户端请求TCP用得到的IP地址建立连接,TCP把数据报传给网络层交给ip协议封装
3)ip协议封装完交给链路层，链路层需要知道ip数据报里的mac地址：先在本机的ARP缓存中查看目的ip的mac地址，查不到就在同一网络内发送ARP广播，如果目的主机与自己在同一网络，就会把自己的mac地址发来，然后链路层才能通过mac地址通信，如果不在同一网络，那么就通过IP选路来确定位于本地网络上的下一跳路由器地址,路由器就暂时充当目的主机把mac地址发来，让源主机把信息发给自己，由他来代理数据转发工作
#ARP和ip协议没有关系，它不是被封装在ip协议中，它是为链路层得到mac地址服务的，

4.3 ARP高速缓存

就是上一节提到的发送ARP请求之前先检查本机ARP缓存，生存时间为20分钟

4.4 ARP的分组格式

详细介绍了ARP数据报的各字段

4.5 ARP举例

用tcpdump命令来看一看运行像Telnet这样的普通TCP工具软件时ARP会做些什么

4.6 ARP代理

谈了4.2提到的源主机与目的主机不在一个网络，通过路由器来代理目的主机

4.7 免费ARP  4.8 arp命令  4.9 小结
不谈


第五章 RARP:逆地址解析协议
整个这一章不谈


第六章 ICMP:Internet控制报文协议


ICMP被封装在IP协议中
ping和tracert命令会用到ICMP	

ping命令流程
（1）Ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同地址“192.168.1.2”一起交给IP协议封装
（2）IP层协议构建一个IP数据包，一并交给数据链路层。
（3）数据链路层构建一个数据帧将它们传送出去。
（4）主机B收到这个数据帧后，接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议，IP层检查后，将信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给A 这就代表A和B可以ping通


第7章 Ping程序


目的是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机,并等待返回ICMP回显应答
ping -r 命令显示经过哪些路由
。。。。。后面就不谈了


第8章 Traceroute程序
不谈


第九章 IP选路  第十章 动态选路协议
不谈


第十一章 UDP:用户数据报协议


11.1 引言

UDP不提供可靠性:它把应用程序传给IP层的数据发送出去,但是并不保证它们能到达目的地

11.5 IP分片
IP协议在传输数据包时，将数据报文分为若干分片进行传输，并在目标主机的ip层进行重组，分片的大小小于路径上链路层的MTU
对于TCP来说，它是尽量避免分片的。如果在传输时，某片数据丢失，则需对整个数据报进行重传。因为IP层本身没有超时重传机制，当来自TCP报文段的某一片丢失后，TCP在超时后重发整个TCP报文段，因为无法只重传一个ip数据报片，因此基于这种原因，TCP是经常要避免分片的

那么TCP层是如何避免IP层的分片呢？

TCP在建立连接时会进行3次握手，而在这3次握手中，客户端和服务端通常会协商一个值，那就是MSS（最长报文大小），用来表示本段所能接收的最大长度的报文段。MSS=MTU-TCP首部大小-IP首部大小，MTU值通过查询链路层得知。
当两端确认好MSS后进行通信，TCP层往IP层传输数据时，如果TCP层缓冲区的大小大于MSS，那么TCP层都会将其中的数据分组进行传输，这样就避免了在IP层进行分片。


第十二章 广播和多播

广播：有时一个主机要向网上的所有其他主机发送帧
多播：网卡获悉该主机属于哪个多播组,然后仅接收主机所在多播组的那些多播帧。
广播和多播仅应用于UDP,tcp只能建立连接后单播


第十三章 IGMP:Internet组管理协议
不谈


第十四章 DNS:域名系统
不谈


第十七章 TCP:传输控制协议


17.1 引言
不谈

17.2 TCP的服务

TCP提供一种面向连接的、可靠的字节流服务

TCP通过下列方式来提供可靠性:
1.应用数据被分割成TCP认为最适合发送的数据块
2.当TCP发出一个段后,它启动一个定时器,等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段
3.当TCP收到发自TCP连接另一端的数据,它将发送一个确认
4.TCP的首部和数据的检验和,目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错,TCP将丢弃这个报文段和不确认收到此报文段
5.既然TCP报文段作为IP数据报来传输,而IP数据报的到达可能会失序,因此TCP报文段的到达也可能会失序,TCP将对收到的数据进行重新排序,将数据以正确的顺序交给应用层
6.TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出


17.3 TCP的首部
源端口和目的端口
序列号(Sequence number)
TCP报文段中的每一个字节都会被赋予一个序列号，保证数据被分组后能按序重组
等于上一个发来的确认号(如果有的话)
确认号(Acknowledgment number)
“确认号的发送方”希望接收的下一个序列号。（即上个发来的序列号+1）
头部长度
该字段表示TCP头部的长度，以32位字为单位
8种状态标识：后面再谈
窗口大小
已发送的分组们，但这些分组还未返回确认号（ACK号）窗口中的分组数量称之为：“窗口大小”
TCP校验和
该校验算法与IP、ICMP、UDP校验算法一致，其覆盖了TCP头部和数据中的一些字段
紧急指针：后面再谈
选项
最常见的选项字段为：“最大段大小”字段，称为MSS。
连接的每个端点（套接字）一般在它发送的第一个报文段上指定该选项。


第十八章 TCP连接的建立与终止

三次握手：
第1步 ：客户端向服务器发送一个同步数据包请求建立连接，该数据包中，初始序列号ISN(Initial Sequence Number)是客户端随机产生的一个值，确认号是0；
发送端  SYN=1，(序列号)Seq=ISN(c),确认号(acknumber)=0  接收端

第2步 ：服务器收到这个同步请求数据包后，会对客户端进行一个同步确认。这个数据包中，序列号（ISN）是服务器随机产生的一个值，确认号是客户端的初始序列号+1；
发送端  SYN=1,ACK=1，(序列号)Seq=ISN(s),确认号(acknumber)=ISN(c)+1  接收端

第3步 ：客户端收到这个同步确认数据包后，再对服务器进行一个确认。该数据包中，序列号是上一个同步请求数据包中的确认号值，确认号是服务器的初始序列号+1。
发送端  ACK=1，(序列号)Seq=ISN(c)+1,确认号(acknumber)=ISN(s)+1  接收端

tcp数据传输：
关键要搞清seq和ack的值
如果知道上面：
seq=上一个ack
ack =上一个seq+上个数据大小


seq  ack  大小  方向
811  0    1      >
818  812  1      <
812  819  0      >
812  819  517    >
819  329  0      <
819  329  1440   <
329  259  0      >
259  329  1369   <
329  628  0      >

四次挥手：
TCP连接是数据在两个方向上能同时传递,因此每个方向必须单独地进行关闭

第一次挥手：客户端先发送FIN报文，用来关闭主动方到被动关闭方的数据传送，也就是客户端告诉服务器：我已经不会再给你发数据了，但此时客户端还可以接受数据。
第二次挥手：Server端接到FIN报文后，服务器端先发送ACK，告诉Client端：请求已经收到了，但是我的数据可能还没有发完，接下来我可能还会发数据，请等待我含有FIN标识的消息。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文
第三次挥手：当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端：服务器这边数据发完了，准备好关闭连接了。
第四次挥手：Client端收到FIN报文后，发送ACK表示收到，知道可以关闭连接了，但是他还是不相信网络，所以后进入TIME_WAIT状态，Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，最后，Client端也可以关闭连接了至此，TCP连接就已经完全关闭了
#MSL(Maximum Segment Lifetime)报文最大生存时间
#客户端发送最后一个针对服务器的FIN的ack之后，担心ack丢包，如果丢包服务器就会重发FIN，从丢包到重发不会超过2MSL，所以客户端要等待这么一段时间

#SYN和FIN都占一个字节


18.5 TCP的半关闭

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，称为半关闭


第十九章 TCP的交互数据流



